# Unity EventBus 아키텍처 구조 분석 및 의사결정

## 1. 도입 배경

게임 내 다양한 시스템(UI, Player, Fishing 등)의 상태 변화에 따라  
UI 갱신이나 반응을 느슨하게 연결하면서 효율적으로 처리하기 위해 **이벤트 기반 구조(EventBus)** 도입을 고려함.

하지만 EventBus는 잘못 사용할 경우 **구조가 흩어지고 추적이 어려워지는 문제**가 있어,  
다양한 설계 방식을 검토하고, 각 방법의 장단점을 비교하여 적절한 구조를 선택함.

---

## 2. 고려한 설계 방식

### [A] EventBus.cs에 모든 이벤트 정의 및 관리 (#region 사용)

- **구조 설명**  
  EventBus 내부에 모든 이벤트 클래스를 정의하고, 도메인별로 `#region`으로 구분하여 관리

- **장점**
  - 구조가 단순하고 파일 수가 적어 관리가 쉬움
  - 빠르게 테스트하거나 소규모 프로젝트에 적합

- **단점**
  - 모든 책임이 한 파일에 집중되어 SRP(단일 책임 원칙) 위반
  - 이벤트 수가 많아질수록 추적/확장 어려움
  - 협업 시 충돌 가능성 큼

---

### [B] 이벤트 정의를 각 도메인에서 사용되는 스크립트에 같이 정의

- **구조 설명**  
  이벤트 클래스를 사용하는 곳(UIController 등)에 함께 정의

- **장점**
  - 사용 맥락을 바로 확인 가능
  - 파일 탐색 없이 코드만 보면 흐름 파악 쉬움

- **단점**
  - 이벤트 재사용 어려움
  - 같은 이벤트를 여러 곳에서 정의하게 될 위험
  - 구조 일관성이 무너짐

---

### [C] 이벤트 정의를 별도의 도메인별 스크립트(UIEvents.cs 등)에 분리

- **구조 설명**  
  모든 이벤트를 도메인(UI, Player, Fishing 등) 기준으로 별도 파일로 분리해 관리

- **장점**
  - 응집도 높고 추적이 쉬움
  - 네임스페이스/이벤트 이름으로 검색 용이
  - 협업에 강하고 Git 충돌 최소화

- **단점**
  - 파일 수 증가
  - 도메인 수가 많아지면 폴더 구조가 복잡해질 수 있음

---

### [D] EventBus는 그대로 유지하되, 구독은 명시적 Registrar에서 일괄 관리

- **구조 설명**  
  구독 Subscribe는 `UIEventRegistrar`, `GameEventRegistrar` 등에서 명시적으로 처리

- **장점**
  - 이벤트 구독 위치가 명확해 디버깅/추적에 강함
  - 구조 통제 가능 → 남용 방지

- **단점**
  - Registrar 클래스가 커질 경우 다시 분할 필요
  - 약간의 설정 번거로움 존재

---

## 3. 비교 및 판단 기준

| 기준 | [A] 단일 EventBus | [B] 사용처에 정의 | [C] 도메인별 분리 | [D] Registrar 분리 |
|------|-------------------|-------------------|--------------------|---------------------|
| 응집도 | ❌ 낮음 | 🔸 보통 | ✅ 높음 | ✅ 높음 |
| 추적성 | ❌ 낮음 | 🔸 맥락 제한적 | ✅ 명확 | ✅ 명확 |
| 재사용성 | 🔸 보통 | ❌ 낮음 | ✅ 좋음 | ✅ 좋음 |
| 확장성 | ❌ 낮음 | ❌ 낮음 | ✅ 좋음 | ✅ 좋음 |
| 설정 편의성 | ✅ 가장 쉬움 | ✅ 쉬움 | 🔸 약간 번거로움 | 🔸 약간 번거로움 |
| Git 협업 | ❌ 충돌 빈번 | 🔸 파일 산재 | ✅ 안정적 | ✅ 안정적 |

---

## 4. 최종 선택 및 설계 전략

### 최종 선택
> **[C] 도메인별 이벤트 정의 분리 + [D] 명시적 Registrar 구조 조합**

### 이유
- UI/Fishing/Player 등 각 기능 단위의 **응집력 있는 이벤트 정의** 가능
- `UIEventRegistrar` 등에서 **구독 위치를 명확히 제어**
- 협업이나 디버깅, 유지보수, 리팩토링 모두 유리한 구조
- 구조가 커져도 **폴더/클래스 단위로 수직 확장 가능**

---

## 5. 실전 적용 방안

### 폴더 구성 예시
```markdown
- Scripts/
  - Core/
    - EventBus.cs
  - Events/
    - UIEvents.cs
    - PlayerEvents.cs
    - FishingEvents.cs
    - SystemEvents.cs
  - UI/
    - CoinUIController.cs
    - UIEventRegistrar.cs
```

### 네이밍 및 네임스페이스
- `Game.Events.UI`, `Game.Events.Player` 등으로 명확히 구분
- 이벤트 이름은 `UpdateCoinUIEvent`, `PlayerLevelUpEvent` 등으로 일관성 유지

---

## 6. 마무리

이번 구조는 **EventBus의 유연성과 구조적 안정성 사이의 균형을 잡은 설계**로,  
소규모 개발에서 출발하여 중대형 프로젝트로 확장해도 무너지지 않는 구성을 목표로 함.

이 구조는 유지보수성과 추적성을 확보하면서도  
불필요한 결합을 줄이고 이벤트 중심 시스템의 이점을 극대화할 수 있다.


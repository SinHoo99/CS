### 1. ```readonly``` vs ```const``` 차이점
   * const : 컴파일 타임 상수, 선언과 동시에 초기화 필요, 변경 불가
   * readonly : 런타임 상수, 생성자에서 초기화 가능, 이후 변경 불가
   * 사용법 : 변하지 않는 값(const), 객체나 동적 값(readonly)에 사용
   ``` csharp
   public const double Pi = 3.14159;  // 컴파일 타임 상수
   public readonly int myValue;  // 런타임 상수 (생성자에서 설정 가능)
   ```
---

### 2. ```interface``` vs ```abstract class``` 차이점
  * ```interface``` : 특정 행동을 강제, 모든 메서드 구현 필수, 다중 상속 가능.
  * ```abstract classs``` : 공통된 동작을 상속, 일부 구현 가능, 단일 상속만 가능.
  * 사용법 : 여러 기능을 추가(``interface``), 공통 기능을 상속(``abstract class``)
 ``` csharp
 interface ISwim { void Swim(); }
 abstract class Animal { public abstract void Move(); }
 ```
---
### 3. ```IEnumerator``` vs ```IEnumerable``` 차이점
  * ```IEnumerable``` : 컬렉션을 ``foreach``에서 사용 가능. ``IEnumerator``를 반환.
  * ```IEnumerator``` : 한 단계씩 반복(``MoveNexy()``사용), 상태 유지 가능.
  * 사용법 : Unity에서 ```IEnumerator```는 코루틴(Coroutine)에서 사용됨.
 ``` csharp
IEnumerator<int> enumerator = myList.GetEnumerator();
while (enumerator.MoveNext()) Console.WriteLine(enumerator.Current);
 ```
---
### 4. ```Time.deltaTime``` vs ```Time.fixedDeltaTime``` 차이점
  * ```Time.deltaTime``` : 프레임 솓도(FPS)에 따라 변하는 시간 (``Update()``에서 사용).
  * ```Time.fixedDeltaTime``` : 일정힌 시간 간격(``FixedUpdate()``에서 사용, 물리 연산에 적합).
 ``` csharp
void Update() { transform.Translate(Vector3.forward * speed * Time.deltaTime); }
void FixedUpdate() { rb.AddForce(Vector3.up * force * Time.fixedDeltaTime); }

 ```
---
### 5. ```GetComponent<T>()``` 캐싱
  * ```GetComponent<T>()```를 매번 호출하며 성능 저하 => 한 번만 호출하고 변수에 저장(캐싱).
 ``` csharp
private Rigidbody rb;
void Awake() { rb = GetComponent<Rigidbody>(); }  // 캐싱
void Update() { rb.AddForce(Vector3.up * 5f); }  // 캐싱된 rb 사용
 ```
---
### 6. ```OnTriggerEnter()``` vs ```OnCollisionEnter()``` 차이점
  * ```OnTriggerEnter()``` : ``insTrigger = true``, 충돌 없이 감지만 가능(적 감지, 아이템 획득).
  * ```OnCollisionEnter``` : ``isTrigger = false``, 실제 물리적 충돌 감지(캐릭터 충돌, 바닥 착지).
 ``` csharp
void OnTriggerEnter(Collider other) { if (other.CompareTag("Enemy")) Debug.Log("적 감지!"); }
void OnCollisionEnter(Collision collision) { if (collision.gameObject.CompareTag("Wall")) Debug.Log("벽과 충돌!"); }
 ```
---
### 7. ```Invoke()``` vs ```Coroutine``` vs ```Update()``` 차이점
| 기능 | 실행 방식 | 언제 사용? |
|------|------|------|
| ``Invoke()`` | 일정 시간 후 한번 실행 | 간단한 시간 딜레이 (ex. 3초 후 이벤트 발생) |
| ``Coroutine`` | ``yield return``으로 특정 시간 대기 후 실행 | 시간이 필요한 애니메이션, 이펙트 |
| ``Update()`` | 매 프레임 실행 | 입력 처리, 이동, UI 업데이트 |
 ``` csharp
void Start() { Invoke("DelayedMethod", 2f); }
IEnumerator MyCoroutine() { yield return new WaitForSeconds(2f); Debug.Log("2초 후 실행!"); }
void Update() { transform.Translate(Vector3.forward * speed * Time.deltaTime); }
 ```
---
### 8. ```Raycast```란?
  * Ray(광선)를 발사하여 특정 방향으로 충돌 감지 (적 탐지, 총알 충돌, 시야 검사).
  * ```Physics.Raycast()```를 사용하여 충돌한 오브젝트 확인 가능.
 ``` csharp
Ray ray = new Ray(transform.position, transform.forward);
if (Physics.Raycast(ray, out RaycastHit hit, 10f))
    Debug.Log("충돌한 오브젝트: " + hit.collider.name);
 ```
✅ 레이어 필터링 (LayerMask 사용)
 ``` csharp
if (Physics.Raycast(ray, out hit, 10f, LayerMask.GetMask("Enemy"))) { Debug.Log("적 감지!"); }
 ```
---

### 9. ```Addressables```이란?
  * Unity의 리소스 로딩 시스템으로, 동적 로드 & 메모리 최적화 가능.
  * 기존 ```Resources.Load()``` 방식보다 효율적이고, 비동기 로딩 지원.
 ``` csharp
public string objectAddress = "MyPrefab";
void Start() { Addressables.LoadAssetAsync<GameObject>(objectAddress).Completed += OnAssetLoaded; }
void OnAssetLoaded(AsyncOperationHandle<GameObject> handle) { if (handle.Status == AsyncOperationStatus.Succeeded) Instantiate(handle.Result); }
 ```
✅ 리소스 해제 (Addressables.Release(handle))를 사용하여 메모리 최적화 가능.

---

### 10. ```Dictionary``` vs ```List``` 차이점
| 기능 | `Dictionary<TKey, TValue>` | `List<T>` |
|------|----------------|-----------|
| **구조** | Key-Value 쌍으로 저장 | 순차적으로 데이터 저장 |
| **중복 허용 여부** | Key 중복 불가 | 모든 요소 중복 가능 |
| **탐색 속도** | `O(1)` (Key로 빠르게 조회) | `O(n)` (Index 또는 `Find()` 사용) |
| **사용 예** | ID → Player 정보 저장 | 플레이어 순위 리스트 |
 ``` csharp
Dictionary<int, string> playerDict = new Dictionary<int, string> { { 1, "Alice" }, { 2, "Bob" } };
List<string> playerList = new List<string> { "Alice", "Bob", "Charlie" };
 ```
✅ 빠른 조회가 필요하면 Dictionary, 순차적인 데이터 관리가 필요하면 List 사용.

---

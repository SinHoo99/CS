## ğŸ“Œ ëª©ì°¨ (Table of Contents)
- [ğŸ“– ê°œìš” (Overview)](#-ê°œìš”-overview)
- [ğŸ¯ í•™ìŠµ ëª©í‘œ (Goals)](#-í•™ìŠµ-ëª©í‘œ-goals)
- [ğŸ“ í•™ìŠµ ì£¼ì œ (Topics)](#-í•™ìŠµ-ì£¼ì œ-topics)
- [ğŸ”— ì°¸ê³  ìë£Œ (References)](#-ì°¸ê³ -ìë£Œ-references)

### 1. ```readonly``` vs ```const``` ì°¨ì´ì  
   * const : ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜, ì„ ì–¸ê³¼ ë™ì‹œì— ì´ˆê¸°í™” í•„ìš”, ë³€ê²½ ë¶ˆê°€
   * readonly : ëŸ°íƒ€ì„ ìƒìˆ˜, ìƒì„±ìì—ì„œ ì´ˆê¸°í™” ê°€ëŠ¥, ì´í›„ ë³€ê²½ ë¶ˆê°€
   * ì‚¬ìš©ë²• : ë³€í•˜ì§€ ì•ŠëŠ” ê°’(const), ê°ì²´ë‚˜ ë™ì  ê°’(readonly)ì— ì‚¬ìš©
   ``` csharp
   public const double Pi = 3.14159;  // ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜
   public readonly int myValue;  // ëŸ°íƒ€ì„ ìƒìˆ˜ (ìƒì„±ìì—ì„œ ì„¤ì • ê°€ëŠ¥)
   ```
---

### 2. ```interface``` vs ```abstract class``` ì°¨ì´ì 
  * ```interface``` : íŠ¹ì • í–‰ë™ì„ ê°•ì œ, ëª¨ë“  ë©”ì„œë“œ êµ¬í˜„ í•„ìˆ˜, ë‹¤ì¤‘ ìƒì† ê°€ëŠ¥.
  * ```abstract classs``` : ê³µí†µëœ ë™ì‘ì„ ìƒì†, ì¼ë¶€ êµ¬í˜„ ê°€ëŠ¥, ë‹¨ì¼ ìƒì†ë§Œ ê°€ëŠ¥.
  * ì‚¬ìš©ë²• : ì—¬ëŸ¬ ê¸°ëŠ¥ì„ ì¶”ê°€(``interface``), ê³µí†µ ê¸°ëŠ¥ì„ ìƒì†(``abstract class``)
 ``` csharp
 interface ISwim { void Swim(); }
 abstract class Animal { public abstract void Move(); }
 ```
---
### 3. ```IEnumerator``` vs ```IEnumerable``` ì°¨ì´ì 
  * ```IEnumerable``` : ì»¬ë ‰ì…˜ì„ ``foreach``ì—ì„œ ì‚¬ìš© ê°€ëŠ¥. ``IEnumerator``ë¥¼ ë°˜í™˜.
  * ```IEnumerator``` : í•œ ë‹¨ê³„ì”© ë°˜ë³µ(``MoveNexy()``ì‚¬ìš©), ìƒíƒœ ìœ ì§€ ê°€ëŠ¥.
  * ì‚¬ìš©ë²• : Unityì—ì„œ ```IEnumerator```ëŠ” ì½”ë£¨í‹´(Coroutine)ì—ì„œ ì‚¬ìš©ë¨.
 ``` csharp
IEnumerator<int> enumerator = myList.GetEnumerator();
while (enumerator.MoveNext()) Console.WriteLine(enumerator.Current);
 ```
---
### 4. ```Time.deltaTime``` vs ```Time.fixedDeltaTime``` ì°¨ì´ì 
  * ```Time.deltaTime``` : í”„ë ˆì„ ì†“ë„(FPS)ì— ë”°ë¼ ë³€í•˜ëŠ” ì‹œê°„ (``Update()``ì—ì„œ ì‚¬ìš©).
  * ```Time.fixedDeltaTime``` : ì¼ì •íŒ ì‹œê°„ ê°„ê²©(``FixedUpdate()``ì—ì„œ ì‚¬ìš©, ë¬¼ë¦¬ ì—°ì‚°ì— ì í•©).
 ``` csharp
void Update() { transform.Translate(Vector3.forward * speed * Time.deltaTime); }
void FixedUpdate() { rb.AddForce(Vector3.up * force * Time.fixedDeltaTime); }

 ```
---
### 5. ```GetComponent<T>()``` ìºì‹±
  * ```GetComponent<T>()```ë¥¼ ë§¤ë²ˆ í˜¸ì¶œí•˜ë©° ì„±ëŠ¥ ì €í•˜ => í•œ ë²ˆë§Œ í˜¸ì¶œí•˜ê³  ë³€ìˆ˜ì— ì €ì¥(ìºì‹±).
 ``` csharp
private Rigidbody rb;
void Awake() { rb = GetComponent<Rigidbody>(); }  // ìºì‹±
void Update() { rb.AddForce(Vector3.up * 5f); }  // ìºì‹±ëœ rb ì‚¬ìš©
 ```
---
### 6. ```OnTriggerEnter()``` vs ```OnCollisionEnter()``` ì°¨ì´ì 
  * ```OnTriggerEnter()``` : ``insTrigger = true``, ì¶©ëŒ ì—†ì´ ê°ì§€ë§Œ ê°€ëŠ¥(ì  ê°ì§€, ì•„ì´í…œ íšë“).
  * ```OnCollisionEnter``` : ``isTrigger = false``, ì‹¤ì œ ë¬¼ë¦¬ì  ì¶©ëŒ ê°ì§€(ìºë¦­í„° ì¶©ëŒ, ë°”ë‹¥ ì°©ì§€).
 ``` csharp
void OnTriggerEnter(Collider other) { if (other.CompareTag("Enemy")) Debug.Log("ì  ê°ì§€!"); }
void OnCollisionEnter(Collision collision) { if (collision.gameObject.CompareTag("Wall")) Debug.Log("ë²½ê³¼ ì¶©ëŒ!"); }
 ```
---
### 7. ```Invoke()``` vs ```Coroutine``` vs ```Update()``` ì°¨ì´ì 
| ê¸°ëŠ¥ | ì‹¤í–‰ ë°©ì‹ | ì–¸ì œ ì‚¬ìš©? |
|------|------|------|
| ``Invoke()`` | ì¼ì • ì‹œê°„ í›„ í•œë²ˆ ì‹¤í–‰ | ê°„ë‹¨í•œ ì‹œê°„ ë”œë ˆì´ (ex. 3ì´ˆ í›„ ì´ë²¤íŠ¸ ë°œìƒ) |
| ``Coroutine`` | ``yield return``ìœ¼ë¡œ íŠ¹ì • ì‹œê°„ ëŒ€ê¸° í›„ ì‹¤í–‰ | ì‹œê°„ì´ í•„ìš”í•œ ì• ë‹ˆë©”ì´ì…˜, ì´í™íŠ¸ |
| ``Update()`` | ë§¤ í”„ë ˆì„ ì‹¤í–‰ | ì…ë ¥ ì²˜ë¦¬, ì´ë™, UI ì—…ë°ì´íŠ¸ |
 ``` csharp
void Start() { Invoke("DelayedMethod", 2f); }
IEnumerator MyCoroutine() { yield return new WaitForSeconds(2f); Debug.Log("2ì´ˆ í›„ ì‹¤í–‰!"); }
void Update() { transform.Translate(Vector3.forward * speed * Time.deltaTime); }
 ```
---
### 8. ```Raycast```ë€?
  * Ray(ê´‘ì„ )ë¥¼ ë°œì‚¬í•˜ì—¬ íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ì¶©ëŒ ê°ì§€ (ì  íƒì§€, ì´ì•Œ ì¶©ëŒ, ì‹œì•¼ ê²€ì‚¬).
  * ```Physics.Raycast()```ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¶©ëŒí•œ ì˜¤ë¸Œì íŠ¸ í™•ì¸ ê°€ëŠ¥.
 ``` csharp
Ray ray = new Ray(transform.position, transform.forward);
if (Physics.Raycast(ray, out RaycastHit hit, 10f))
    Debug.Log("ì¶©ëŒí•œ ì˜¤ë¸Œì íŠ¸: " + hit.collider.name);
 ```
âœ… ë ˆì´ì–´ í•„í„°ë§ (LayerMask ì‚¬ìš©)
 ``` csharp
if (Physics.Raycast(ray, out hit, 10f, LayerMask.GetMask("Enemy"))) { Debug.Log("ì  ê°ì§€!"); }
 ```
---

### 9. ```Addressables```ì´ë€?
  * Unityì˜ ë¦¬ì†ŒìŠ¤ ë¡œë”© ì‹œìŠ¤í…œìœ¼ë¡œ, ë™ì  ë¡œë“œ & ë©”ëª¨ë¦¬ ìµœì í™” ê°€ëŠ¥.
  * ê¸°ì¡´ ```Resources.Load()``` ë°©ì‹ë³´ë‹¤ íš¨ìœ¨ì ì´ê³ , ë¹„ë™ê¸° ë¡œë”© ì§€ì›.
 ``` csharp
public string objectAddress = "MyPrefab";
void Start() { Addressables.LoadAssetAsync<GameObject>(objectAddress).Completed += OnAssetLoaded; }
void OnAssetLoaded(AsyncOperationHandle<GameObject> handle) { if (handle.Status == AsyncOperationStatus.Succeeded) Instantiate(handle.Result); }
 ```
âœ… ë¦¬ì†ŒìŠ¤ í•´ì œ (Addressables.Release(handle))ë¥¼ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ìµœì í™” ê°€ëŠ¥.

---

### 10. ```Dictionary``` vs ```List``` ì°¨ì´ì  (Overview)
| ê¸°ëŠ¥ | `Dictionary<TKey, TValue>` | `List<T>` |
|------|----------------|-----------|
| **êµ¬ì¡°** | Key-Value ìŒìœ¼ë¡œ ì €ì¥ | ìˆœì°¨ì ìœ¼ë¡œ ë°ì´í„° ì €ì¥ |
| **ì¤‘ë³µ í—ˆìš© ì—¬ë¶€** | Key ì¤‘ë³µ ë¶ˆê°€ | ëª¨ë“  ìš”ì†Œ ì¤‘ë³µ ê°€ëŠ¥ |
| **íƒìƒ‰ ì†ë„** | `O(1)` (Keyë¡œ ë¹ ë¥´ê²Œ ì¡°íšŒ) | `O(n)` (Index ë˜ëŠ” `Find()` ì‚¬ìš©) |
| **ì‚¬ìš© ì˜ˆ** | ID â†’ Player ì •ë³´ ì €ì¥ | í”Œë ˆì´ì–´ ìˆœìœ„ ë¦¬ìŠ¤íŠ¸ |
 ``` csharp
Dictionary<int, string> playerDict = new Dictionary<int, string> { { 1, "Alice" }, { 2, "Bob" } };
List<string> playerList = new List<string> { "Alice", "Bob", "Charlie" };
 ```
âœ… ë¹ ë¥¸ ì¡°íšŒê°€ í•„ìš”í•˜ë©´ Dictionary, ìˆœì°¨ì ì¸ ë°ì´í„° ê´€ë¦¬ê°€ í•„ìš”í•˜ë©´ List ì‚¬ìš©.

---
